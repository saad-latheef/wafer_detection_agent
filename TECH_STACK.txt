# Technology Stack

## Wafer Detection Agent - Complete Tech Stack Documentation

---

## Backend Stack

### Core Framework
- **FastAPI** (Latest)
  - High-performance async web framework
  - Auto-generated OpenAPI/Swagger documentation
  - Built-in validation with Pydantic
  - WebSocket support for real-time updates
  - CORS middleware for cross-origin requests

### Python Version
- **Python 3.11+**
  - Modern type hints support
  - Performance improvements
  - Enhanced error messages
  - Better async/await support

### Machine Learning Frameworks

#### PyTorch
- **Version**: Latest stable
- **Usage**: Primary ML framework for ResNet18 and k_cross_CNN models
- **Components**:
  - torch: Core tensor operations
  - torchvision: Pre-trained models and image transforms
  - torch.nn.functional: Neural network operations
- **Models**:
  - `best_model.pt`: ResNet18 for image classification (99.98% accuracy)
  - `k_cross_CNN.pt`: Custom CNN for NPY wafer maps

#### TensorFlow/Keras
- **Version**: 2.x
- **Usage**: Ensemble model component
- **Components**:
  - tensorflow: Core framework
  - keras: High-level API
- **Models**:
  - `my_model.weights.h5`: TensorFlow model for NPY ensemble
  - `ViT_Wafer_Defect.h5`: Vision Transformer (optional)

### AI/Agent Framework
- **Google ADK** (Agentic Development Kit)
  - Multi-agent orchestration
  - Tool/function calling
  - LLM integration (Gemini)
  - Agent state management
  - Sequential agent execution

### Database
- **SQLite**
  - Lightweight, serverless database
  - Zero configuration required
  - ACID compliant
  - Perfect for single-instance applications
- **SQLAlchemy ORM**
  - Object-relational mapping
  - Database migrations support
  - Query building and optimization
  - Connection pooling

### Web Server
- **Uvicorn**
  - ASGI server for FastAPI
  - Hot-reload in development
  - Production-ready performance
  - HTTP/1.1 and HTTP/2 support

### Data Processing
- **NumPy**: Array operations and mathematical functions
- **Pillow (PIL)**: Image loading, processing, and transformation
- **Python-Multipart**: File upload handling

---

## Frontend Stack

### Core Framework
- **Next.js 15**
  - React-based framework with App Router
  - Server-side rendering (SSR)
  - Static site generation (SSG)
  - File-based routing
  - Built-in optimization

### UI Library
- **React 19**
  - Latest React version with Server Components
  - Improved hooks and state management
  - Concurrent rendering
  - Automatic batching

### Language
- **TypeScript**
  - Type-safe development
  - Enhanced IDE support
  - Better code documentation
  - Catch errors at compile time

### Styling
- **Tailwind CSS**
  - Utility-first CSS framework
  - JIT (Just-In-Time) compilation
  - Responsive design utilities
  - Dark mode support
  - Custom theme configuration

### Component Library
- **Shadcn UI**
  - Beautiful, accessible components
  - Built on Radix UI primitives
  - Fully customizable
  - Copy-paste component workflow
  - Components used:
    - Card, Button, Badge, Input
    - Progress, Tabs, Select
    - Dialog, Popover, Tooltip
    - Chart components

### Icons
- **Lucide React**
  - Clean, consistent icon set
  - Tree-shakeable
  - Customizable size and color
  - 1000+ icons available

### Data Visualization
- **Recharts**
  - React-based charting library
  - Responsive charts
  - Composable chart components
  - Used for: pie charts, line graphs, bar charts

### Build Tools
- **Turbopack** (Next.js built-in)
  - Fast bundler written in Rust
  - Incremental compilation
  - Development hot-reload
- **PostCSS**: CSS transformation
- **ESLint**: Code linting
- **Prettier**: Code formatting (optional)

---

## Development Tools

### Version Control
- **Git**
  - Source code management
  - Branch-based workflow
  - Commit history tracking

### Package Managers
- **npm** / **pnpm**
  - Node.js package management
  - Dependency resolution
  - Lock files for reproducibility

- **pip**
  - Python package management
  - requirements.txt for dependencies
  - Virtual environment support

### Development Environment
- **Virtual Environment (venv)**
  - Isolated Python environments
  - Dependency management
  - Reproducible builds

---

## Model Architecture Details

### 1. ResNet18 (Image Classifier)
**File**: `best_model.pt`
**Framework**: PyTorch
**Architecture**:
- **Input**: 224×224 RGB images
- **Base**: ResNet18 pre-trained on ImageNet
- **Modified**: Final FC layer for 9 classes
- **Features**: 11.7M parameters
- **Normalization**:
  - Mean: [0.485, 0.456, 0.406]
  - Std: [0.229, 0.224, 0.225]
- **Output**: Softmax probabilities for 9 defect classes
- **Performance**: 99.98% accuracy on test set

**How it works**:
1. Image loaded and resized to 224×224
2. Converted to tensor and normalized with ImageNet stats
3. Forward pass through ResNet18
4. Softmax applied to get probability distribution
5. Highest probability class selected as prediction

### 2. k_cross_CNN (NPY Wafer Maps)
**File**: `k_cross_CNN.pt`
**Framework**: PyTorch
**Architecture**:
- **Input**: 26×26×3 wafer maps (NCHW format)
- **Custom CNN**: Multiple conv layers with pooling
- **Features**: Designed for spatial pattern recognition
- **Output**: 9 classes (including "none" for normal)
- **Training**: K-fold cross-validation for robustness

**How it works**:
1. NPY file loaded as 26×26 array
2. Expanded to 3 channels if needed
3. Converted to PyTorch tensor
4. Forward pass through CNN
5. Softmax for probability distribution
6. Uses NPY_CLASS_NAMES for class mapping

### 3. my_model.weights.h5 (TensorFlow Ensemble)
**File**: `my_model.weights.h5`
**Framework**: TensorFlow/Keras
**Architecture**:
- **Input**: 26×26×3 wafer maps (NHWC format)
- **Custom Architecture**: TensorFlow-based CNN
- **Training**: Independent model for ensemble
- **Output**: 9 class probabilities

**How it works**:
1. Tensor converted from PyTorch (NCHW) to TensorFlow (NHWC)
2. Predict using Keras model
3. Softmax probabilities returned
4. Combined with k_cross_CNN for ensemble

### 4. Ensemble Strategy
**Method**: Best Confidence Selection
**Process**:
1. Both models (k_cross_CNN + my_model) run inference
2. Each returns probability distribution
3. Compare max confidence from each model
4. Select prediction with highest confidence
5. Return winning model's full probability distribution

**Benefits**:
- Improved robustness
- Reduced false positives
- Handles edge cases better
- Cross-validation between frameworks

---

## API Architecture

### REST API Design
- **Protocol**: HTTP/HTTPS
- **Format**: JSON for request/response
- **File Upload**: multipart/form-data
- **Authentication**: None (can be added)
- **Rate Limiting**: None (can be added)

### Endpoints Structure
```
/api/
├── analyze          (POST) - Single wafer analysis
├── analyze-lot      (POST) - Batch analysis
├── history          (GET)  - Scan history retrieval
├── spc              (GET)  - SPC chart data
├── equipment-correlation (GET) - Tool analysis
├── copilot/query    (POST) - AI copilot queries
└── docs             (GET)  - API documentation
```

---

## Data Flow

### Single Wafer Analysis Pipeline
1. **Frontend**: User uploads file → FormData with tool_id/chamber_id
2. **API**: FastAPI receives multipart request
3. **Ingestion Agent**: Validates and preprocesses file
4. **ML Agent**: Runs appropriate model(s) based on file type
5. **Analysis Agent**: Analyzes probability distribution
6. **Validation Agent**: Cross-checks and determines verdict
7. **Explanation Agent**: Generates natural language summary
8. **Database**: Saves complete result to SQLite
9. **API Response**: Returns JSON with agent results
10. **Frontend**: Displays results in 3-card UI

### AI Copilot Flow
1. **User**: Asks question in natural language
2. **Frontend**: Sends query to /api/copilot/query
3. **Backend**: Fetches last 100 wafers from database
4. **ADK Agent**: Processes query with database context
5. **Gemini LLM**: Generates intelligent response
6. **Response**: Returns formatted markdown with suggestions
7. **Frontend**: Displays answer in chat interface

---

## Security Considerations

### Current Implementation
- CORS enabled for localhost:3000
- No authentication (development mode)
- File type validation (images and NPY only)
- SQL injection protected by SQLAlchemy ORM
- No sensitive data encryption

### Production Recommendations
- Add JWT authentication
- Implement rate limiting
- Use HTTPS with SSL certificates
- Add file size limits
- Implement user roles/permissions
- Enable logging and monitoring
- Add API key for copilot

---

## Performance Characteristics

### Model Inference Speed
- **ResNet18**: ~50-100ms per image (CPU)
- **ResNet18**: ~10-20ms per image (GPU)
- **Ensemble**: ~100-200ms per NPY file (CPU)

### API Response Time
- Single analysis: 200-500ms (including DB save)
- Batch analysis: Linear scaling with file count
- History retrieval: <50ms for 50 records

### Database
- SQLite: Handles up to 100k records efficiently
- For production scale: Consider PostgreSQL/MySQL

---

## Deployment Options

### Development
- Local servers: `python start_backend.py` + `npm run dev`
- Hot-reload enabled for both frontend and backend
- Separate terminals for each service

### Production (Options)
1. **Docker**:
   - Backend: Python + FastAPI container
   - Frontend: Node.js build + serve container
   - Docker Compose for orchestration

2. **Cloud Platforms**:
   - Vercel/Netlify: Frontend deployment
   - Railway/Render: Backend deployment
   - AWS/GCP/Azure: Full-stack deployment

3. **Process Manager**:
   - PM2 for Node.js processes
   - Supervisor for Python processes
   - Nginx as reverse proxy

---

**Last Updated**: January 2026
**Maintainer**: Wafer Detection Agent Team
